kruskals algorithm:
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int i, j, k, a, b, u, v, n, ne = 1;
int min, mincost = 0, cost[9][9], parent[9];
int find(int);
int uni(int, int);

int main()
{
    clock_t start, end;
    double cpu_time_used;

    printf("Kruskal's algorithm in C\n");
    printf("========================\n");
    printf("Enter the no. of vertices:\n");
    scanf("%d", &n);

    printf("\nEnter the cost adjacency matrix:\n");
    start = clock(); // Start timer

    for (i = 1; i <= n; i++)
    {
        for (j = 1; j <= n; j++)
        {
            scanf("%d", &cost[i][j]);
            if (cost[i][j] == 0)
                cost[i][j] = 999; // Replace 0 with high value
        }
    }

    printf("The edges of Minimum Cost Spanning Tree are\n");

    while (ne < n)
    {
        for (i = 1, min = 999; i <= n; i++)
        {
            for (j = 1; j <= n; j++)
            {
                if (cost[i][j] < min)
                {
                    min = cost[i][j];
                    a = u = i;
                    b = v = j;
                }
            }
        }

        u = find(u);
        v = find(v);

        if (uni(u, v))
        {
            printf("%d edge (%d,%d) = %d\n", ne++, a, b, min);
            mincost += min;
        }

        cost[a][b] = cost[b][a] = 999;
    }

    printf("\nMinimum cost = %d\n", mincost);

    end = clock(); // End timer
    cpu_time_used = ((double)(end - start)) / CLOCKS_PER_SEC;
    printf("Execution time: %f seconds\n", cpu_time_used);

    return 0;
}

int find(int i)
{
    while (parent[i])
        i = parent[i];
    return i;
}

int uni(int i, int j)
{
    if (i != j)
    {
        parent[j] = i;
        return 1;
    }
    return 0;
}
DIJIKSTRAS ALGORITHM:
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define INFINITY 9999
#define MAX 10

void dijkstra(int G[MAX][MAX], int n, int startnode);

int main()
{
    int G[MAX][MAX], i, j, n, u;
    clock_t start, end;
    double cpu_time_used;

    printf("Dijkstra's Algorithm in C\n");
    printf("=========================\n");
    printf("Enter number of vertices: ");
    scanf("%d", &n);

    printf("\nEnter the adjacency matrix:\n");
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            scanf("%d", &G[i][j]);

    printf("\nEnter the starting node: ");
    scanf("%d", &u);

    start = clock(); // start timer

    dijkstra(G, n, u);

    end = clock(); // end timer
    cpu_time_used = ((double)(end - start)) / CLOCKS_PER_SEC;
    printf("\n\nExecution time: %f seconds\n", cpu_time_used);

    printf("\nTime Complexity: O(V^2)\n");

    return 0;
}

void dijkstra(int G[MAX][MAX], int n, int startnode)
{
    int cost[MAX][MAX], distance[MAX], pred[MAX];
    int visited[MAX], count, mindistance, nextnode, i, j;

    // create the cost matrix
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            if (G[i][j] == 0)
                cost[i][j] = INFINITY;
            else
                cost[i][j] = G[i][j];

    // initialize pred[], distance[] and visited[]
    for (i = 0; i < n; i++)
    {
        distance[i] = cost[startnode][i];
        pred[i] = startnode;
        visited[i] = 0;
    }

    distance[startnode] = 0;
    visited[startnode] = 1;
    count = 1;

    while (count < n - 1)
    {
        mindistance = INFINITY;

        // find the next node with the minimum distance
        for (i = 0; i < n; i++)
            if (distance[i] < mindistance && !visited[i])
            {
                mindistance = distance[i];
                nextnode = i;
            }

        visited[nextnode] = 1;
        for (i = 0; i < n; i++)
            if (!visited[i])
                if (mindistance + cost[nextnode][i] < distance[i])
                {
                    distance[i] = mindistance + cost[nextnode][i];
                    pred[i] = nextnode;
                }

        count++;
    }

    // print the path and distance of each node
    for (i = 0; i < n; i++)
        if (i != startnode)
        {
            printf("\nDistance of node %d = %d", i, distance[i]);
            printf("\nPath = %d", i);

            j = i;
            do
            {
                j = pred[j];
                printf(" <- %d", j);
            } while (j != startnode);
        }
}
CONVEX HULL:
#include <stdio.h>
#include <stdlib.h>
#include<time.h>

// Structure to represent a point
typedef struct
{
int first;
int second;
} Pair;

// Global variable to store the center of the polygon
Pair mid;

// Function to determine the quadrant of a point
int quad(Pair p)
{
if (p.first >= 0 && p.second >= 0)
return 1;
if (p.first <= 0 && p.second >= 0)
return 2;
if (p.first <= 0 && p.second <= 0)
return 3;
return 4;
}

// Function to check the orientation of three points
int orientation(Pair a, Pair b, Pair c)
{
int res = (b.second - a.second) * (c.first - b.first) - (c.second - b.second) * (b.first - a.first);

if (res == 0)
return 0;
if (res > 0)
return 1;
return -1;
}

// Compare function for sorting
int compare(const void *p1, const void *q1)
{
Pair *p = (Pair *)p1;
Pair *q = (Pair *)q1;

Pair p_diff = {p->first - mid.first, p->second - mid.second};
Pair q_diff = {q->first - mid.first, q->second - mid.second};

int one = quad(p_diff);
int two = quad(q_diff);

if (one != two)
return (one < two) ? -1 : 1;

return (p_diff.second * q_diff.first < q_diff.second * p_diff.first) ? -1 : 1;
}

// Function to merge two convex hulls
Pair *merger(Pair *a, int n1, Pair *b, int n2, int *ret_size)
{
int ia = 0, ib = 0;
for (int i = 1; i < n1; i++)
if (a[i].first > a[ia].first)
ia = i;

for (int i = 1; i < n2; i++)
if (b[i].first < b[ib].first)
ib = i;

int inda = ia, indb = ib;
int done = 0;
while (!done)
{
done = 1;
while (orientation(b[indb], a[inda], a[(inda + 1) % n1]) >= 0)
inda = (inda + 1) % n1;

while (orientation(a[inda], b[indb], b[(n2 + indb - 1) % n2]) <= 0)
{

indb = (n2 + indb - 1) % n2;
done = 0;
}
}

int uppera = inda, upperb = indb;
inda = ia;
indb = ib;
done = 0;
while (!done)
{
done = 1;
while (orientation(a[inda], b[indb], b[(indb + 1) % n2]) >= 0)
indb = (indb + 1) % n2;

while (orientation(b[indb], a[inda], a[(n1 + inda - 1) % n1]) <= 0)
{
inda = (n1 + inda - 1) % n1;
done = 0;
}
}

int lowera = inda, lowerb = indb;
Pair *ret = (Pair *)malloc((n1 + n2) * sizeof(Pair));
int ind = uppera;
int k = 0;

ret[k++] = a[uppera];
while (ind != lowera)
{
ind = (ind + 1) % n1;
ret[k++] = a[ind];
}

ind = lowerb;
ret[k++] = b[lowerb];
while (ind != upperb)
{
ind = (ind + 1) % n2;
ret[k++] = b[ind];
}

*ret_size = k;
return ret;
}

// Brute force algorithm to find the convex hull for a small set of points
Pair *bruteHull(Pair *a, int n, int *ret_size)
{
int max_combinations = n * (n - 1) / 2;
Pair *ret = (Pair *)malloc(n * sizeof(Pair));
int k = 0;

for (int i = 0; i < n; i++)
{
for (int j = i + 1; j < n; j++)
{
int x1 = a[i].first, x2 = a[j].first;
int y1 = a[i].second, y2 = a[j].second;

int a1 = y1 - y2;
int b1 = x2 - x1;
int c1 = x1 * y2 - y1 * x2;
int pos = 0, neg = 0;

for (int m = 0; m < n; m++)
{
if (a1 * a[m].first + b1 * a[m].second + c1 <= 0)
neg++;
if (a1 * a[m].first + b1 * a[m].second + c1 >= 0)
pos++;
}

if (pos == n || neg == n)
{
int already_added = 0;
for (int l = 0; l < k; l++)
{

if (ret[l].first == a[i].first && ret[l].second == a[i].second)
already_added = 1;
}
if (!already_added)
ret[k++] = a[i];

already_added = 0;
for (int l = 0; l < k; l++)
{
if (ret[l].first == a[j].first && ret[l].second == a[j].second)
already_added = 1;
}
if (!already_added)
ret[k++] = a[j];
}
}
}

*ret_size = k;
ret = (Pair *)realloc(ret, k * sizeof(Pair));

mid.first = 0;
mid.second = 0;
for (int i = 0; i < k; i++)
{
mid.first += ret[i].first;

mid.second += ret[i].second;
ret[i].first *= k;
ret[i].second *= k;
}

qsort(ret, k, sizeof(Pair), compare);

for (int i = 0; i < k; i++)
{
ret[i].first /= k;
ret[i].second /= k;
}

return ret;
}

// Function to divide the set of points and recursively find the convex hull
Pair *divide(Pair *a, int n, int *ret_size)
{
if (n <= 5)
return bruteHull(a, n, ret_size);

int mid = n / 2;
Pair *left_hull;
Pair *right_hull;
int left_size, right_size;

left_hull = divide(a, mid, &left_size);
right_hull = divide(a + mid, n - mid, &right_size);

return merger(left_hull, left_size, right_hull, right_size, ret_size);
}

// Driver code
int main()
{
Pair a[] = {{0, 0}, {1, -4}, {-1, -5}, {-5, -3}, {-3, -1},
{-1, -3}, {-2, -2}, {-1, -1}, {-2, -1}, {-1, 1}};
int n = sizeof(a) / sizeof(a[0]);
clock_t start,end;
double cpu_time_used;
start = clock();

qsort(a, n, sizeof(Pair), compare);
int ret_size;
Pair *ans = divide(a, n, &ret_size);

printf("Convex hull:\n");
for (int i = 0; i < ret_size; i++)
{
printf("%d %d\n", ans[i].first, ans[i].second);
}

free(ans);
end=clock();
cpu_time_used=((double)(end-start)/CLOCKS_PER_SEC);
printf("execution time : %f seconds",cpu_time_used);
return 0;

}
MILLER RABIT UNIT:

#include <stdio.h>
#include <stdlib.h>
#include<time.h>

// Function to perform modular exponentiation
long long power_mod(long long base, long long exp, long long mod) {
long long result = 1;
base = base % mod;
while (exp > 0) {
if (exp % 2 == 1) {
result = (result * base) % mod;
}
exp = exp >> 1;
base = (base * base) % mod;
}
return result;
}

// Miller-Rabin test for a single iteration
int miller_rabin_test(long long n, long long d) {
long long a = 2 + rand() % (n - 4); // Random base in range [2, n-2]
long long x = power_mod(a, d, n);

if (x == 1 || x == n - 1) {
return 1; // Probably prime

}

while (d != n - 1) {
x = (x * x) % n;
d *= 2;

if (x == 1) return 0; // Composite
if (x == n - 1) return 1; // Probably prime
}

return 0; // Composite
}

// Miller-Rabin Primality Test
int is_prime(long long n, int k) {
if (n <= 1 || n == 4) return 0; // Not prime
if (n <= 3) return 1; // Prime

long long d = n - 1;
while (d % 2 == 0) {
d /= 2;
}

for (int i = 0; i < k; i++) {
if (!miller_rabin_test(n, d)) {
return 0; // Composite

}
}

return 1; // Probably prime
}

int main() {
long long n;
int k = 5;
clock_t start,end;
double cpu_time_used;
start=clock();// Number of iterations for accuracy

printf("Enter a number to check if it is prime: ");
scanf("%lld", &n);

if (is_prime(n, k)) {
printf("%lld is a prime number.\n", n);
} else {
printf("%lld is not a prime number.\n", n);
}
end=clock();
cpu_time_used=((double)(end-start)/CLOCKS_PER_SEC);
printf("execution time;%f seconds",cpu_time_used);
return 0;
}


